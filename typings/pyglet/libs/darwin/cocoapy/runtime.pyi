"""
This type stub file was generated by pyright.
"""

from ctypes import *
from .cocoatypes import *

__LP64__ = ...
__i386__ = ...
__arm64__ = ...
if sizeof(c_void_p) == 4:
    c_ptrdiff_t = ...
else:
    c_ptrdiff_t = ...
lib = ...
if lib is None:
    lib = ...
objc = ...
if not__arm64__:
    ...
if not__arm64__:
    ...
if not__arm64__:
    ...
class OBJC_METHOD_DESCRIPTION(Structure):
    _fields_ = ...


def ensure_bytes(x): # -> bytes:
    ...

def get_selector(name): # -> c_void_p:
    ...

def get_class(name): # -> c_void_p:
    ...

def get_object_class(obj): # -> c_void_p:
    ...

def get_metaclass(name): # -> c_void_p:
    ...

def get_superclass_of_object(obj): # -> c_void_p:
    ...

def x86_should_use_stret(restype): # -> bool:
    """Try to figure out when a return type will be passed on stack."""
    ...

def should_use_fpret(restype): # -> bool:
    """Determine if objc_msgSend_fpret is required to return a floating point type."""
    ...

def send_message(receiver, selName, *args, **kwargs): # -> Any | c_void_p:
    ...

class OBJC_SUPER(Structure):
    _fields_ = ...


OBJC_SUPER_PTR = ...
def send_super(receiver, selName, *args, superclass_name=..., **kwargs): # -> c_void_p | Any:
    ...

cfunctype_table = ...
def parse_type_encoding(encoding): # -> list[Unknown]:
    """Takes a type encoding string and outputs a list of the separated type codes.
    Currently does not handle unions or bitfields and strips out any field width
    specifiers or type specifiers from the encoding.  For Python 3.2+, encoding is
    assumed to be a bytes object and not unicode.

    Examples:
    parse_type_encoding('^v16@0:8') --> ['^v', '@', ':']
    parse_type_encoding('{CGSize=dd}40@0:8{CGSize=dd}16Q32') --> ['{CGSize=dd}', '@', ':', '{CGSize=dd}', 'Q']
    """
    ...

def cfunctype_for_encoding(encoding): # -> Type[_FuncPointer]:
    ...

def create_subclass(superclass, name): # -> c_void_p:
    ...

def register_subclass(subclass): # -> None:
    ...

def add_method(cls, selName, method, types): # -> _FuncPointer:
    ...

def add_ivar(cls, name, vartype): # -> Any:
    ...

def set_instance_variable(obj, varname, value, vartype): # -> None:
    ...

def get_instance_variable(obj, varname, vartype):
    ...

class ObjCMethod:
    """This represents an unbound Objective-C method (really an IMP)."""
    typecodes = ...
    cfunctype_table = ...
    def __init__(self, method) -> None:
        """Initialize with an Objective-C Method pointer.  We then determine
        the return type and argument type information of the method."""
        ...
    
    def ctype_for_encoding(self, encoding): # -> Type[c_byte] | Type[c_int] | Type[c_short] | Type[c_long] | Type[c_longlong] | Type[c_ubyte] | Type[c_uint] | Type[c_ushort] | Type[c_ulong] | Type[c_ulonglong] | Type[c_float] | Type[c_double] | Type[c_bool] | Type[c_char_p] | Type[c_void_p] | Type[NSPoint] | Type[NSSize] | Type[NSRect] | Type[NSRange] | Type[py_object[Unknown]] | Type[_Pointer[Unknown]] | None:
        """Return ctypes type for an encoded Objective-C type."""
        ...
    
    def get_prototype(self): # -> Type[_FuncPointer]:
        """Returns a ctypes CFUNCTYPE for the method."""
        ...
    
    def __repr__(self): # -> LiteralString:
        ...
    
    def get_callable(self): # -> _FuncPointer:
        """Returns a python-callable version of the method's IMP."""
        ...
    
    def __call__(self, objc_id, *args): # -> ObjCClass | Any | None:
        """Call the method with the given id and arguments.  You do not need
        to pass in the selector as an argument since it will be automatically
        provided."""
        ...
    


class ObjCBoundMethod:
    """This represents an Objective-C method (an IMP) which has been bound
    to some id which will be passed as the first parameter to the method."""
    def __init__(self, method, objc_id) -> None:
        """Initialize with a method and ObjCInstance or ObjCClass object."""
        ...
    
    def __repr__(self): # -> LiteralString:
        ...
    
    def __call__(self, *args):
        """Call the method with the given arguments."""
        ...
    


class ObjCClass:
    """Python wrapper for an Objective-C class."""
    _registered_classes = ...
    def __new__(cls, class_name_or_ptr): # -> Self@ObjCClass:
        """Create a new ObjCClass instance or return a previously created
        instance for the given Objective-C class.  The argument may be either
        the name of the class to retrieve, or a pointer to the class."""
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def cache_instance_methods(self): # -> None:
        """Create and store python representations of all instance methods
        implemented by this class (but does not find methods of superclass)."""
        ...
    
    def cache_class_methods(self): # -> None:
        """Create and store python representations of all class methods
        implemented by this class (but does not find methods of superclass)."""
        ...
    
    def get_instance_method(self, name): # -> ObjCMethod | None:
        """Returns a python representation of the named instance method,
        either by looking it up in the cached list of methods or by searching
        for and creating a new method object."""
        ...
    
    def get_class_method(self, name): # -> ObjCMethod | None:
        """Returns a python representation of the named class method,
        either by looking it up in the cached list of methods or by searching
        for and creating a new method object."""
        ...
    
    def __getattr__(self, name): # -> ObjCBoundMethod | ObjCMethod:
        """Returns a callable method object with the given name."""
        ...
    


class ObjCInstance:
    """Python wrapper for an Objective-C instance."""
    _cached_objects = ...
    def __new__(cls, object_ptr): # -> Self@ObjCInstance | None:
        """Create a new ObjCInstance or return a previously created one
        for the given object_ptr which should be an Objective-C id."""
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __getattr__(self, name): # -> ObjCBoundMethod:
        """Returns a callable method object with the given name."""
        ...
    


def convert_method_arguments(encoding, args): # -> list[Unknown]:
    """Used by ObjCSubclass to convert Objective-C method arguments to
    Python values before passing them on to the Python-defined method."""
    ...

class ObjCSubclass:
    """Use this to create a subclass of an existing Objective-C class.
    It consists primarily of function decorators which you use to add methods
    to the subclass."""
    def __init__(self, superclass, name, register=...) -> None:
        ...
    
    def register(self): # -> None:
        """Register the new class with the Objective-C runtime."""
        ...
    
    def add_ivar(self, varname, vartype): # -> Any:
        """Add instance variable named varname to the subclass.
        varname should be a string.
        vartype is a ctypes type.
        The class must be registered AFTER adding instance variables."""
        ...
    
    def add_method(self, method, name, encoding): # -> None:
        ...
    
    def add_class_method(self, method, name, encoding): # -> None:
        ...
    
    def rawmethod(self, encoding): # -> (f: Unknown) -> Unknown:
        """Decorator for instance methods without any fancy shenanigans.
        The function must have the signature f(self, cmd, *args)
        where both self and cmd are just pointers to objc objects."""
        ...
    
    def method(self, encoding): # -> (f: Unknown) -> ((objc_self: Unknown, objc_cmd: Unknown, *args: Unknown) -> Unknown):
        """Function decorator for instance methods."""
        ...
    
    def classmethod(self, encoding): # -> (f: Unknown) -> ((objc_cls: Unknown, objc_cmd: Unknown, *args: Unknown) -> Unknown):
        """Function decorator for class methods."""
        ...
    


class DeallocationObserver_Implementation:
    DeallocationObserver = ...
    @DeallocationObserver.rawmethod('@@')
    def initWithObject_(self, cmd, anObject): # -> int | Any | None:
        ...
    
    @DeallocationObserver.rawmethod('v')
    def dealloc(self, cmd): # -> None:
        ...
    
    @DeallocationObserver.rawmethod('v')
    def finalize(self, cmd): # -> None:
        ...
    


