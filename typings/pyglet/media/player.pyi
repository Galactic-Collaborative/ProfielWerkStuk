"""
This type stub file was generated by pyright.
"""

import pyglet

"""High-level sound and video player."""
_debug = ...
class PlaybackTimer:
    """Playback Timer.

    This is a simple timer object which tracks the time elapsed. It can be
    paused and reset.
    """
    def __init__(self) -> None:
        """Initialize the timer with time 0."""
        ...
    
    def start(self): # -> None:
        """Start the timer."""
        ...
    
    def pause(self): # -> None:
        """Pause the timer."""
        ...
    
    def reset(self): # -> None:
        """Reset the timer to 0."""
        ...
    
    def get_time(self): # -> float:
        """Get the elapsed time."""
        ...
    
    def set_time(self, value): # -> None:
        """
        Manually set the elapsed time.

        Args:
            value (float): the new elapsed time value
        """
        ...
    


class _PlayerProperty:
    """Descriptor for Player attributes to forward to the AudioPlayer.

    We want the Player to have attributes like volume, pitch, etc. These are
    actually implemented by the AudioPlayer. So this descriptor will forward
    an assignement to one of the attributes to the AudioPlayer. For example
    `player.volume = 0.5` will call `player._audio_player.set_volume(0.5)`.

    The Player class has default values at the class level which are retrieved
    if not found on the instance.
    """
    def __init__(self, attribute, doc=...) -> None:
        ...
    
    def __get__(self, obj, objtype=...): # -> Self@_PlayerProperty | Any:
        ...
    
    def __set__(self, obj, value): # -> None:
        ...
    


class Player(pyglet.event.EventDispatcher):
    """High-level sound and video player."""
    _volume = ...
    _min_distance = ...
    _max_distance = ...
    _position = ...
    _pitch = ...
    _cone_orientation = ...
    _cone_inner_angle = ...
    _cone_outer_angle = ...
    _cone_outer_gain = ...
    def __init__(self) -> None:
        """Initialize the Player with a MasterClock."""
        ...
    
    def __del__(self): # -> None:
        """Release the Player resources."""
        ...
    
    def queue(self, source): # -> None:
        """
        Queue the source on this player.

        If the player has no source, the player will start to play immediately
        or pause depending on its :attr:`.playing` attribute.

        Args:
            source (Source or Iterable[Source]): The source to queue.
        """
        ...
    
    @property
    def playing(self): # -> bool:
        """
        bool: Read-only. Determine if the player state is playing.

        The *playing* property is irrespective of whether or not there is
        actually a source to play. If *playing* is ``True`` and a source is
        queued, it will begin to play immediately. If *playing* is ``False``,
        it is implied that the player is paused. There is no other possible
        state.
        """
        ...
    
    def play(self): # -> None:
        """Begin playing the current source.

        This has no effect if the player is already playing.
        """
        ...
    
    def pause(self): # -> None:
        """Pause playback of the current source.

        This has no effect if the player is already paused.
        """
        ...
    
    def delete(self): # -> None:
        """Release the resources acquired by this player.

        The internal audio player and the texture will be deleted.
        """
        ...
    
    def next_source(self): # -> None:
        """Move immediately to the next source in the current playlist.

        If the playlist is empty, discard it and check if another playlist
        is queued. There may be a gap in playback while the audio buffer
        is refilled.
        """
        ...
    
    def seek(self, timestamp): # -> None:
        """
        Seek for playback to the indicated timestamp on the current source.

        Timestamp is expressed in seconds. If the timestamp is outside the
        duration of the source, it will be clamped to the end.

        Args:
            timestamp (float): The time where to seek in the source, clamped to the
                beginning and end of the source.
        """
        ...
    
    @property
    def source(self): # -> None:
        """Source: Read-only. The current :class:`Source`, or ``None``."""
        ...
    
    @property
    def time(self): # -> float:
        """
        float: Read-only. Current playback time of the current source.

        The playback time is a float expressed in seconds, with 0.0 being the
        beginning of the media. The playback time returned represents the
        player master clock time which is used to synchronize both the audio
        and the video.
        """
        ...
    
    @property
    def texture(self): # -> Texture | None:
        """
        :class:`pyglet.image.Texture`: Get the texture for the current video frame.

        You should call this method every time you display a frame of video,
        as multiple textures might be used. The return value will be None if
        there is no video in the current source.
        """
        ...
    
    def get_texture(self): # -> Texture | None:
        """
        Get the texture for the current video frame.

        You should call this method every time you display a frame of video,
        as multiple textures might be used. The return value will be None if
        there is no video in the current source.

        Returns:
            :class:`pyglet.image.Texture`

        .. deprecated:: 1.4
                Use :attr:`~texture` instead
        """
        ...
    
    def refill_buffer(self):
        ...
    
    def seek_next_frame(self): # -> None:
        """Step forwards one video frame in the current source."""
        ...
    
    def update_texture(self, dt=...): # -> None:
        """Manually update the texture from the current source.

        This happens automatically, so you shouldn't need to call this method.

        Args:
            dt (float): The time elapsed since the last call to
                ``update_texture``.
        """
        ...
    
    volume = ...
    min_distance = ...
    max_distance = ...
    position = ...
    pitch = ...
    cone_orientation = ...
    cone_inner_angle = ...
    cone_outer_angle = ...
    cone_outer_gain = ...
    def on_player_eos(self): # -> None:
        """The player ran out of sources. The playlist is empty.

        :event:
        """
        ...
    
    def on_eos(self): # -> None:
        """The current source ran out of data.

        The default behaviour is to advance to the next source in the
        playlist if the :attr:`.loop` attribute is set to ``False``.
        If :attr:`.loop` attribute is set to ``True``, the current source
        will start to play again until :meth:`next_source` is called or
        :attr:`.loop` is set to ``False``.

        :event:
        """
        ...
    
    def on_player_next_source(self): # -> None:
        """The player starts to play the next queued source in the playlist.

        This is a useful event for adjusting the window size to the new
        source :class:`VideoFormat` for example.

        :event:
        """
        ...
    
    def on_driver_reset(self): # -> None:
        """The audio driver has been reset, by default this will kill the current audio player and create a new one,
        and requeue the buffers. Any buffers that may have been queued in a player will be resubmitted.  It will
        continue from the last buffers submitted, not played and may cause sync issues if using video.

        :event:
        """
        ...
    


class PlayerGroup:
    """Group of players that can be played and paused simultaneously.

    Create a player group for the given list of players.

    All players in the group must currently not belong to any other group.

    Args:
        players (List[Player]): List of :class:`.Player` s in this group.
    """
    def __init__(self, players) -> None:
        """Initialize the PlayerGroup with the players."""
        ...
    
    def play(self): # -> None:
        """Begin playing all players in the group simultaneously."""
        ...
    
    def pause(self): # -> None:
        """Pause all players in the group simultaneously."""
        ...
    


