"""
This type stub file was generated by pyright.
"""

from pyglet import graphics
from pyglet.gl import *
from pyglet.event import EventDispatcher

"""Render simple text and formatted documents efficiently.

Three layout classes are provided:

:py:class:`~pyglet.text.layout.TextLayout`
    The entire document is laid out before it is rendered.  The layout will
    be grouped with other layouts in the same batch (allowing for efficient
    rendering of multiple layouts).

    Any change to the layout or document,
    and even querying some properties, will cause the entire document
    to be laid out again.

:py:class:`~pyglet.text.layout.ScrollableTextLayout`
    Based on :py:func:`~pyglet.text.layout.TextLayout`.

    A separate group is used for layout which crops the contents of the
    layout to the layout rectangle.  Additionally, the contents of the
    layout can be "scrolled" within that rectangle with the ``view_x`` and
    ``view_y`` properties.

:py:class:`~pyglet.text.layout.IncrementalTextLayout`
    Based on :py:class:`~pyglet.text.layout.ScrollableTextLayout`.

    When the layout or document are modified, only the affected regions
    are laid out again.  This permits efficient interactive editing and
    styling of text.

    Only the visible portion of the layout is actually rendered; as the
    viewport is scrolled additional sections are rendered and discarded as
    required.  This permits efficient viewing and editing of large documents.

    Additionally, this class provides methods for locating the position of a
    caret in the document, and for displaying interactive text selections.

All three layout classes can be used with either :py:class:`~pyglet.text.document.UnformattedDocument` or
:py:class:`~pyglet.text.document.FormattedDocument`, and can be either single-line or ``multiline``.  The
combinations of these options effectively provides 12 different text display
possibilities.

Style attributes
================

The following character style attribute names are recognised by the layout
classes.  Data types and units are as specified.

Where an attribute is marked "as a distance" the value is assumed to be
in pixels if given as an int or float, otherwise a string of the form
``"0u"`` is required, where ``0`` is the distance and ``u`` is the unit; one
of ``"px"`` (pixels), ``"pt"`` (points), ``"pc"`` (picas), ``"cm"``
(centimeters), ``"mm"`` (millimeters) or ``"in"`` (inches).  For example,
``"14pt"`` is the distance covering 14 points, which at the default DPI of 96
is 18 pixels.

``font_name``
    Font family name, as given to :py:func:`pyglet.font.load`.
``font_size``
    Font size, in points.
``bold``
    Boolean.
``italic``
    Boolean.
``underline``
    4-tuple of ints in range (0, 255) giving RGBA underline color, or None
    (default) for no underline.
``kerning``
    Additional space to insert between glyphs, as a distance.  Defaults to 0.
``baseline``
    Offset of glyph baseline from line baseline, as a distance.  Positive
    values give a superscript, negative values give a subscript.  Defaults to
    0.
``color``
    4-tuple of ints in range (0, 255) giving RGBA text color
``background_color``
    4-tuple of ints in range (0, 255) giving RGBA text background color; or
    ``None`` for no background fill.

The following paragraph style attribute names are recognised.  Note
that paragraph styles are handled no differently from character styles by the
document: it is the application's responsibility to set the style over an
entire paragraph, otherwise results are undefined.

``align``
    ``left`` (default), ``center`` or ``right``.
``indent``
    Additional horizontal space to insert before the first glyph of the
    first line of a paragraph, as a distance.
``leading``
    Additional space to insert between consecutive lines within a paragraph,
    as a distance.  Defaults to 0.
``line_spacing``
    Distance between consecutive baselines in a paragraph, as a distance.
    Defaults to ``None``, which automatically calculates the tightest line
    spacing for each line based on the font ascent and descent.
``margin_left``
    Left paragraph margin, as a distance.
``margin_right``
    Right paragraph margin, as a distance.
``margin_top``
    Margin above paragraph, as a distance.
``margin_bottom``
    Margin below paragraph, as a distance.  Adjacent margins do not collapse.
``tab_stops``
    List of horizontal tab stops, as distances, measured from the left edge of
    the text layout.  Defaults to the empty list.  When the tab stops
    are exhausted, they implicitly continue at 50 pixel intervals.
``wrap``
    ``char``, ``word``, True (default) or False.  The boundaries at which to
    wrap text to prevent it overflowing a line.  With ``char``, the line
    wraps anywhere in the text; with ``word`` or True, the line wraps at
    appropriate boundaries between words; with False the line does not wrap,
    and may overflow the layout width.  ``char`` and ``word`` styles are
    since pyglet 1.2.

Other attributes can be used to store additional style information within the
document; they will be ignored by the built-in text classes.

.. versionadded:: 1.1
"""
_is_pyglet_doc_run = ...
_distance_re = ...
class _Line:
    align = ...
    margin_left = ...
    margin_right = ...
    length = ...
    ascent = ...
    descent = ...
    width = ...
    paragraph_begin = ...
    paragraph_end = ...
    x = ...
    y = ...
    def __init__(self, start) -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def add_box(self, box): # -> None:
        ...
    
    def delete(self, layout): # -> None:
        ...
    


class _LayoutContext:
    def __init__(self, layout, document, colors_iter, background_iter) -> None:
        ...
    


class _StaticLayoutContext(_LayoutContext):
    def __init__(self, layout, document, colors_iter, background_iter) -> None:
        ...
    
    def add_list(self, vertex_list): # -> None:
        ...
    
    def add_box(self, box): # -> None:
        ...
    


class _IncrementalLayoutContext(_LayoutContext):
    line = ...
    def add_list(self, vertex_list): # -> None:
        ...
    
    def add_box(self, box): # -> None:
        ...
    


class _AbstractBox:
    owner = ...
    def __init__(self, ascent, descent, advance, length) -> None:
        ...
    
    def place(self, layout, i, x, y, z, rotation, anchor_x, anchor_y, context):
        ...
    
    def delete(self, layout):
        ...
    
    def get_position_in_box(self, x):
        ...
    
    def get_point_in_box(self, position):
        ...
    


class _GlyphBox(_AbstractBox):
    def __init__(self, owner, font, glyphs, advance) -> None:
        """Create a run of glyphs sharing the same texture.

        :Parameters:
            `owner` : `pyglet.image.Texture`
                Texture of all glyphs in this run.
            `font` : `pyglet.font.base.Font`
                Font of all glyphs in this run.
            `glyphs` : list of (int, `pyglet.font.base.Glyph`)
                Pairs of ``(kern, glyph)``, where ``kern`` gives horizontal
                displacement of the glyph in pixels (typically 0).
            `advance` : int
                Width of glyph run; must correspond to the sum of advances
                and kerns in the glyph list.

        """
        ...
    
    def place(self, layout, i, x, y, z, rotation, anchor_x, anchor_y, context): # -> None:
        ...
    
    def delete(self, layout): # -> None:
        ...
    
    def get_point_in_box(self, position): # -> Literal[0]:
        ...
    
    def get_position_in_box(self, x): # -> int:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class _InlineElementBox(_AbstractBox):
    def __init__(self, element) -> None:
        """Create a glyph run holding a single element.
        """
        ...
    
    def place(self, layout, i, x, y, z, rotation, anchor_x, anchor_y, context): # -> None:
        ...
    
    def delete(self, layout): # -> None:
        ...
    
    def get_point_in_box(self, position): # -> Unknown | Literal[0]:
        ...
    
    def get_position_in_box(self, x): # -> Literal[0, 1]:
        ...
    
    def __repr__(self): # -> str:
        ...
    


class _InvalidRange:
    def __init__(self) -> None:
        ...
    
    def insert(self, start, length): # -> None:
        ...
    
    def delete(self, start, end): # -> None:
        ...
    
    def invalidate(self, start, end): # -> None:
        ...
    
    def validate(self): # -> tuple[int | Unknown, int | Unknown]:
        ...
    
    def is_invalid(self): # -> bool:
        ...
    


layout_vertex_source = ...
layout_fragment_source = ...
layout_fragment_image_source = ...
decoration_vertex_source = ...
decoration_fragment_source = ...
def get_default_layout_shader(): # -> ShaderProgram:
    ...

def get_default_image_layout_shader(): # -> ShaderProgram:
    ...

def get_default_decoration_shader(): # -> ShaderProgram:
    ...

class TextLayoutGroup(graphics.Group):
    def __init__(self, texture, program, order=..., parent=...) -> None:
        """Create a text layout rendering group.

        The group is created internally when a :py:class:`~pyglet.text.Label`
        is created; applications usually do not need to explicitly create it.
        """
        ...
    
    def set_state(self): # -> None:
        ...
    
    def unset_state(self): # -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    


class ScrollableTextLayoutGroup(graphics.Group):
    scissor_area = ...
    def __init__(self, texture, program, order=..., parent=...) -> None:
        """Default rendering group for :py:class:`~pyglet.text.layout.ScrollableTextLayout`.

        The group maintains internal state for specifying the viewable
        area, and for scrolling. Because the group has internal state
        specific to the text layout, the group is never shared.
        """
        ...
    
    def set_state(self): # -> None:
        ...
    
    def unset_state(self): # -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    


class IncrementalTextLayoutGroup(ScrollableTextLayoutGroup):
    scissor_area = ...


class TextDecorationGroup(graphics.Group):
    def __init__(self, program, order=..., parent=...) -> None:
        """Create a text decoration rendering group.

        The group is created internally when a :py:class:`~pyglet.text.Label`
        is created; applications usually do not need to explicitly create it.
        """
        ...
    
    def set_state(self): # -> None:
        ...
    
    def unset_state(self): # -> None:
        ...
    


class ScrollableTextDecorationGroup(graphics.Group):
    scissor_area = ...
    def __init__(self, program, order=..., parent=...) -> None:
        """Create a text decoration rendering group.

        The group is created internally when a :py:class:`~pyglet.text.Label`
        is created; applications usually do not need to explicitly create it.
        """
        ...
    
    def set_state(self): # -> None:
        ...
    
    def unset_state(self): # -> None:
        ...
    
    def __repr__(self): # -> str:
        ...
    
    def __eq__(self, other) -> bool:
        ...
    
    def __hash__(self) -> int:
        ...
    


class IncrementalTextDecorationGroup(ScrollableTextDecorationGroup):
    scissor_area = ...


class TextLayout:
    """Lay out and display documents.

    This class is intended for displaying documents that do not change
    regularly -- any change will cost some time to lay out the complete
    document again and regenerate all vertex lists.

    The benefit of this class is that texture state is shared between
    all layouts of this class.  The time to draw one :py:func:`~pyglet.text.layout.TextLayout` may be
    roughly the same as the time to draw one :py:class:`~pyglet.text.layout.IncrementalTextLayout`; but
    drawing ten :py:func:`~pyglet.text.layout.TextLayout` objects in one batch is much faster than drawing
    ten incremental or scrollable text layouts.

    :py:func:`~pyglet.text.Label` and :py:func:`~pyglet.text.HTMLLabel` provide a convenient interface to this class.

    :Ivariables:
        `content_width` : int
            Calculated width of the text in the layout.  This may overflow
            the desired width if word-wrapping failed.
        `content_height` : int
            Calculated height of the text in the layout.
        `group_class` : `~pyglet.graphics.Group`
            Top-level rendering group.
        `background_decoration_group` : `~pyglet.graphics.Group`
            Rendering group for background color.
        `foreground_decoration_group` : `~pyglet.graphics.Group`
            Rendering group for glyph underlines.

    """
    _document = ...
    _vertex_lists = ...
    _boxes = ...
    _update_enabled = ...
    _own_batch = ...
    group_class = TextLayoutGroup
    decoration_class = TextDecorationGroup
    _x = ...
    _y = ...
    _z = ...
    _rotation = ...
    _width = ...
    _height = ...
    _anchor_x = ...
    _anchor_y = ...
    _content_valign = ...
    _multiline = ...
    _visible = ...
    def __init__(self, document, width=..., height=..., multiline=..., dpi=..., batch=..., group=..., wrap_lines=...) -> None:
        """Create a text layout.

        :Parameters:
            `document` : `AbstractDocument`
                Document to display.
            `width` : int
                Width of the layout in pixels, or None
            `height` : int
                Height of the layout in pixels, or None
            `multiline` : bool
                If False, newline and paragraph characters are ignored, and
                text is not word-wrapped.
                If True, text is wrapped only if the `wrap_lines` is True.
            `dpi` : float
                Font resolution; defaults to 96.
            `batch` : `~pyglet.graphics.Batch`
                Optional graphics batch to add this layout to.
            `group` : `~pyglet.graphics.Group`
                Optional Group to parent all internal Groups that this text
                layout uses.  Note that layouts with the same Groups will
                be rendered simultaneously in a Batch.
            `wrap_lines` : bool
                If True and `multiline` is True, the text is word-wrapped using
                the specified width.

        """
        ...
    
    @property
    def group(self): # -> None:
        ...
    
    @group.setter
    def group(self, group): # -> None:
        ...
    
    @property
    def dpi(self): # -> int:
        """Get DPI used by this layout.

        :type: float
        """
        ...
    
    @property
    def document(self): # -> None:
        """Document to display.

         For :py:class:`~pyglet.text.layout.IncrementalTextLayout` it is
         far more efficient to modify a document in-place than to replace
         the document instance on the layout.

         :type: `AbstractDocument`
         """
        ...
    
    @document.setter
    def document(self, document): # -> None:
        ...
    
    @property
    def batch(self): # -> Batch:
        """The Batch that this Layout is assigned to.

        If no Batch is assigned, an internal Batch is
        created and used.

        :type: :py:class:`~pyglet.graphics.Batch`

        """
        ...
    
    @batch.setter
    def batch(self, batch): # -> None:
        ...
    
    @property
    def x(self): # -> int:
        """X coordinate of the layout.

        See also :py:attr:`~pyglet.text.layout.TextLayout.anchor_x`.

        :type: int
        """
        ...
    
    @x.setter
    def x(self, x): # -> None:
        ...
    
    @property
    def y(self): # -> int:
        """Y coordinate of the layout.

        See also `anchor_y`.

        :type: int
        """
        ...
    
    @y.setter
    def y(self, y): # -> None:
        ...
    
    @property
    def z(self): # -> int:
        """Z coordinate of the layout.

        :type: int
        """
        ...
    
    @z.setter
    def z(self, z): # -> None:
        ...
    
    @property
    def rotation(self): # -> int:
        """Rotation of the layout.
        
        :type: float
        """
        ...
    
    @rotation.setter
    def rotation(self, rotation): # -> None:
        ...
    
    @property
    def position(self): # -> tuple[int | Unknown, int | Unknown, int | Unknown]:
        """The (X, Y, Z) coordinates of the layout, as a tuple.

        See also :py:attr:`~pyglet.text.layout.TextLayout.anchor_x`,
        and :py:attr:`~pyglet.text.layout.TextLayout.anchor_y`.

        :type: (int, int, int)
        """
        ...
    
    @position.setter
    def position(self, values): # -> None:
        ...
    
    @property
    def visible(self): # -> bool:
        """True if the layout will be drawn.

        :type: bool
        """
        ...
    
    @visible.setter
    def visible(self, value): # -> None:
        ...
    
    @property
    def width(self): # -> None:
        """Width of the layout.

        This property has no effect if `multiline` is False or `wrap_lines` is False.

        :type: int
        """
        ...
    
    @width.setter
    def width(self, width): # -> None:
        ...
    
    @property
    def height(self): # -> None:
        """Height of the layout.

        :type: int
        """
        ...
    
    @height.setter
    def height(self, height): # -> None:
        ...
    
    @property
    def multiline(self): # -> bool:
        """Set if multiline layout is enabled.

        If multiline is False, newline and paragraph characters are ignored and
        text is not word-wrapped.
        If True, the text is word-wrapped only if the `wrap_lines` is True.

        :type: bool
        """
        ...
    
    @multiline.setter
    def multiline(self, multiline): # -> None:
        ...
    
    @property
    def anchor_x(self): # -> str:
        """Horizontal anchor alignment.

        This property determines the meaning of the `x` coordinate.
        It is one of the enumerants:

        ``"left"`` (default)
            The X coordinate gives the position of the left edge of the layout.
        ``"center"``
            The X coordinate gives the position of the center of the layout.
        ``"right"``
            The X coordinate gives the position of the right edge of the layout.

        For the purposes of calculating the position resulting from this
        alignment, the width of the layout is taken to be `width` if `multiline`
        is True and `wrap_lines` is True, otherwise `content_width`.

        :type: str
        """
        ...
    
    @anchor_x.setter
    def anchor_x(self, anchor_x): # -> None:
        ...
    
    @property
    def anchor_y(self): # -> str:
        """Vertical anchor alignment.

        This property determines the meaning of the `y` coordinate.
        It is one of the enumerants:

        ``"top"``
            The Y coordinate gives the position of the top edge of the layout.
        ``"center"``
            The Y coordinate gives the position of the center of the layout.
        ``"baseline"``
            The Y coordinate gives the position of the baseline of the first
            line of text in the layout.
        ``"bottom"`` (default)
            The Y coordinate gives the position of the bottom edge of the layout.

        For the purposes of calculating the position resulting from this
        alignment, the height of the layout is taken to be the smaller of
        `height` and `content_height`.

        See also `content_valign`.

        :type: str
        """
        ...
    
    @anchor_y.setter
    def anchor_y(self, anchor_y): # -> None:
        ...
    
    @property
    def content_valign(self): # -> str:
        """Vertical alignment of content within larger layout box.

        This property determines how content is positioned within the layout
        box when ``content_height`` is less than ``height``.  It is one
        of the enumerants:

        ``top`` (default)
            Content is aligned to the top of the layout box.
        ``center``
            Content is centered vertically within the layout box.
        ``bottom``
            Content is aligned to the bottom of the layout box.

        This property has no effect when ``content_height`` is greater
        than ``height`` (in which case the content is aligned to the top) or when
        ``height`` is ``None`` (in which case there is no vertical layout box
        dimension).

        :type: str
        """
        ...
    
    @content_valign.setter
    def content_valign(self, content_valign): # -> None:
        ...
    
    def parse_distance(self, distance): # -> int | None:
        ...
    
    def begin_update(self): # -> None:
        """Indicate that a number of changes to the layout or document
        are about to occur.

        Changes to the layout or document between calls to `begin_update` and
        `end_update` do not trigger any costly relayout of text.  Relayout of
        all changes is performed when `end_update` is called.

        Note that between the `begin_update` and `end_update` calls, values
        such as `content_width` and `content_height` are undefined (i.e., they
        may or may not be updated to reflect the latest changes).
        """
        ...
    
    def end_update(self): # -> None:
        """Perform pending layout changes since `begin_update`.

        See `begin_update`.
        """
        ...
    
    def delete(self): # -> None:
        """Remove this layout from its batch.
        """
        ...
    
    def draw(self): # -> None:
        """Draw this text layout.

        Note that this method performs very badly if a batch was supplied to
        the constructor.  If you add this layout to a batch, you should
        ideally use only the batch's draw method.
        """
        ...
    
    def on_insert_text(self, start, text): # -> None:
        """Event handler for `AbstractDocument.on_insert_text`.

        The event handler is bound by the text layout; there is no need for
        applications to interact with this method.
        """
        ...
    
    def on_delete_text(self, start, end): # -> None:
        """Event handler for `AbstractDocument.on_delete_text`.

        The event handler is bound by the text layout; there is no need for
        applications to interact with this method.
        """
        ...
    
    def on_style_text(self, start, end, attributes): # -> None:
        """Event handler for `AbstractDocument.on_style_text`.

        The event handler is bound by the text layout; there is no need for
        applications to interact with this method.
        """
        ...
    


class ScrollableTextLayout(TextLayout):
    """Display text in a scrollable viewport.

    This class does not display a scrollbar or handle scroll events; it merely
    clips the text that would be drawn in :py:func:`~pyglet.text.layout.TextLayout`
    to the bounds of the layout given by `x`, `y`, `width` and `height`;
    and offsets the text by a scroll offset.

    Use `view_x` and `view_y` to scroll the text within the viewport.
    """
    group_class = ScrollableTextLayoutGroup
    decoration_class = ScrollableTextDecorationGroup
    _translate_x = ...
    _translate_y = ...
    def __init__(self, document, width, height, multiline=..., dpi=..., batch=..., group=..., wrap_lines=...) -> None:
        ...
    
    @property
    def x(self): # -> int:
        ...
    
    @x.setter
    def x(self, x): # -> None:
        ...
    
    @property
    def y(self): # -> int:
        ...
    
    @y.setter
    def y(self, y): # -> None:
        ...
    
    @property
    def position(self): # -> tuple[int | Unknown, int | Unknown, int | Unknown]:
        ...
    
    @position.setter
    def position(self, position): # -> None:
        ...
    
    @property
    def anchor_x(self):
        ...
    
    @anchor_x.setter
    def anchor_x(self, anchor_x): # -> None:
        ...
    
    @property
    def anchor_y(self):
        ...
    
    @anchor_y.setter
    def anchor_y(self, anchor_y): # -> None:
        ...
    
    @property
    def view_x(self): # -> int:
        """Horizontal scroll offset.

            The initial value is 0, and the left edge of the text will touch the left
            side of the layout bounds.  A positive value causes the text to "scroll"
            to the right.  Values are automatically clipped into the range
            ``[0, content_width - width]``

            :type: int
        """
        ...
    
    @view_x.setter
    def view_x(self, view_x): # -> None:
        ...
    
    @property
    def view_y(self): # -> int:
        """Vertical scroll offset.

            The initial value is 0, and the top of the text will touch the top of the
            layout bounds (unless the content height is less than the layout height,
            in which case `content_valign` is used).

            A negative value causes the text to "scroll" upwards.  Values outside of
            the range ``[height - content_height, 0]`` are automatically clipped in
            range.

            :type: int
        """
        ...
    
    @view_y.setter
    def view_y(self, view_y): # -> None:
        ...
    


class IncrementalTextLayout(TextLayout, EventDispatcher):
    """Displayed text suitable for interactive editing and/or scrolling
    large documents.

    Unlike :py:func:`~pyglet.text.layout.TextLayout` and
    :py:class:`~pyglet.text.layout.ScrollableTextLayout`, this class generates
    vertex lists only for lines of text that are visible.  As the document is
    scrolled, vertex lists are deleted and created as appropriate to keep
    video memory usage to a minimum and improve rendering speed.

    Changes to the document are quickly reflected in this layout, as only the
    affected line(s) are reflowed.  Use `begin_update` and `end_update` to
    further reduce the amount of processing required.

    The layout can also display a text selection (text with a different
    background color).  The :py:class:`~pyglet.text.caret.Caret` class implements
    a visible text cursor and provides event handlers for scrolling, selecting and
    editing text in an incremental text layout.
    """
    _selection_start = ...
    _selection_end = ...
    _selection_color = ...
    _selection_background_color = ...
    group_class = IncrementalTextLayoutGroup
    decoration_class = IncrementalTextDecorationGroup
    _translate_x = ...
    _translate_y = ...
    def __init__(self, document, width, height, multiline=..., dpi=..., batch=..., group=..., wrap_lines=...) -> None:
        ...
    
    def delete(self): # -> None:
        ...
    
    def on_insert_text(self, start, text): # -> None:
        ...
    
    def on_delete_text(self, start, end): # -> None:
        ...
    
    def on_style_text(self, start, end, attributes): # -> None:
        ...
    
    @property
    def x(self):
        ...
    
    @x.setter
    def x(self, x): # -> None:
        ...
    
    @property
    def y(self):
        ...
    
    @y.setter
    def y(self, y): # -> None:
        ...
    
    @property
    def position(self): # -> tuple[Unknown, Unknown, Unknown]:
        ...
    
    @position.setter
    def position(self, position): # -> None:
        ...
    
    @property
    def anchor_x(self):
        ...
    
    @anchor_x.setter
    def anchor_x(self, anchor_x): # -> None:
        ...
    
    @property
    def anchor_y(self):
        ...
    
    @anchor_y.setter
    def anchor_y(self, anchor_y): # -> None:
        ...
    
    @property
    def width(self):
        ...
    
    @width.setter
    def width(self, width): # -> None:
        ...
    
    @property
    def height(self):
        ...
    
    @height.setter
    def height(self, height): # -> None:
        ...
    
    @property
    def multiline(self):
        ...
    
    @multiline.setter
    def multiline(self, multiline): # -> None:
        ...
    
    @property
    def view_x(self): # -> int:
        """Horizontal scroll offset.

        The initial value is 0, and the left edge of the text will touch the left
        side of the layout bounds.  A positive value causes the text to "scroll"
        to the right.  Values are automatically clipped into the range
        ``[0, content_width - width]``

        :type: int
        """
        ...
    
    @view_x.setter
    def view_x(self, view_x): # -> None:
        ...
    
    @property
    def view_y(self): # -> int:
        """Vertical scroll offset.

        The initial value is 0, and the top of the text will touch the top of the
        layout bounds (unless the content height is less than the layout height,
        in which case `content_valign` is used).

        A negative value causes the text to "scroll" upwards.  Values outside of
        the range ``[height - content_height, 0]`` are automatically clipped in
        range.

        :type: int
        """
        ...
    
    @view_y.setter
    def view_y(self, view_y): # -> None:
        ...
    
    def set_selection(self, start, end): # -> None:
        """Set the text selection range.

        If ``start`` equals ``end`` no selection will be visible.

        :Parameters:
            `start` : int
                Starting character position of selection.
            `end` : int
                End of selection, exclusive.

        """
        ...
    
    @property
    def selection_start(self): # -> int:
        """Starting position of the active selection.

        :see: `set_selection`

        :type: int
        """
        ...
    
    @selection_start.setter
    def selection_start(self, start): # -> None:
        ...
    
    @property
    def selection_end(self): # -> int:
        """End position of the active selection (exclusive).

        :see: `set_selection`

        :type: int
        """
        ...
    
    @selection_end.setter
    def selection_end(self, end): # -> None:
        ...
    
    @property
    def selection_color(self): # -> list[int]:
        """Text color of active selection.

        The color is an RGBA tuple with components in range [0, 255].

        :type: (int, int, int, int)
        """
        ...
    
    @selection_color.setter
    def selection_color(self, color): # -> None:
        ...
    
    @property
    def selection_background_color(self): # -> list[int]:
        """Background color of active selection.

        The color is an RGBA tuple with components in range [0, 255].

        :type: (int, int, int, int)
        """
        ...
    
    @selection_background_color.setter
    def selection_background_color(self, background_color): # -> None:
        ...
    
    def get_position_from_point(self, x, y):
        """Get the closest document position to a point.

        :Parameters:
            `x` : int
                X coordinate
            `y` : int
                Y coordinate

        """
        ...
    
    def get_point_from_position(self, position, line=...): # -> tuple[Unknown, Unknown]:
        """Get the X, Y coordinates of a position in the document.

        The position that ends a line has an ambiguous point: it can be either
        the end of the line, or the beginning of the next line.  You may
        optionally specify a line index to disambiguate the case.

        The resulting Y coordinate gives the baseline of the line.

        :Parameters:
            `position` : int
                Character position within document.
            `line` : int
                Line index.

        :rtype: (int, int)
        :return: (x, y)
        """
        ...
    
    def get_line_from_point(self, x, y): # -> int:
        """Get the closest line index to a point.

        :Parameters:
            `x` : int
                X coordinate.
            `y` : int
                Y coordinate.

        :rtype: int
        """
        ...
    
    def get_point_from_line(self, line): # -> tuple[Unknown, Unknown]:
        """Get the X, Y coordinates of a line index.

        :Parameters:
            `line` : int
                Line index.

        :rtype: (int, int)
        :return: (x, y)
        """
        ...
    
    def get_line_from_position(self, position): # -> int:
        """Get the line index of a character position in the document.

        :Parameters:
            `position` : int
                Document position.

        :rtype: int
        """
        ...
    
    def get_position_from_line(self, line):
        """Get the first document character position of a given line index.

        :Parameters:
            `line` : int
                Line index.

        :rtype: int
        """
        ...
    
    def get_position_on_line(self, line, x):
        """Get the closest document position for a given line index and X
        coordinate.

        :Parameters:
            `line` : int
                Line index.
            `x` : int
                X coordinate.

        :rtype: int
        """
        ...
    
    def get_line_count(self): # -> int:
        """Get the number of lines in the text layout.

        :rtype: int
        """
        ...
    
    def ensure_line_visible(self, line): # -> None:
        """Adjust `view_y` so that the line with the given index is visible.

        :Parameters:
            `line` : int
                Line index.

        """
        ...
    
    def ensure_x_visible(self, x): # -> None:
        """Adjust `view_x` so that the given X coordinate is visible.

        The X coordinate is given relative to the current `view_x`.

        :Parameters:
            `x` : int
                X coordinate

        """
        ...
    
    if _is_pyglet_doc_run:
        def on_layout_update(self): # -> None:
            """Some or all of the layout text was reflowed.

            Text reflow is caused by document edits or changes to the layout's
            size.  Changes to the layout's position or active selection, and
            certain document edits such as text color, do not cause a reflow.

            Handle this event to update the position of a graphical element
            that depends on the laid out position of a glyph or line.

            :event:
            """
            ...
        


